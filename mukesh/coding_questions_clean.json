[
    {
        "title": "Count Even Numbers in an Array",
        "description": "You are given an array of integers. Your task is to count how many numbers in the array are even.",
        "difficulty": "Easy",
        "label": [
            "array",
            "math",
            "iteration"
        ],
        "sample input": [
            2,
            5,
            8,
            11,
            14
        ],
        "sample output": 3,
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9",
        "_id": 2
    },
    {
        "title": "Check if a String is a Palindrome",
        "description": "Given a string, determine if it is a palindrome. Return true if it reads the same forwards and backwards.",
        "difficulty": "Easy",
        "label": [
            "string",
            "two-pointers",
            "logic"
        ],
        "sample input": "madonna",
        "sample output": false,
        "constraints": "1 <= string length <= 10^5; only lowercase English letters allowed",
        "_id": 3
    },
    {
        "title": "Sum of Digits",
        "description": "Given an integer, return the sum of all its digits.",
        "difficulty": "Easy",
        "label": [
            "math",
            "digits",
            "iteration"
        ],
        "sample input": 4521,
        "sample output": 12,
        "constraints": "0 <= number <= 10^18",
        "_id": 4
    },
    {
        "title": "Reverse an Array",
        "description": "Given an array of integers, return a new array that contains all elements in reverse order.",
        "difficulty": "Easy",
        "label": [
            "array",
            "two-pointers",
            "manipulation"
        ],
        "sample input": [
            1,
            2,
            3,
            4,
            5
        ],
        "sample output": [
            5,
            4,
            3,
            2,
            1
        ],
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9",
        "_id": 5
    },
    {
        "title": "Find the Index of a Target Element",
        "description": "Given an array and a target value, return the index of the target if it exists in the array. If it does not exist, return -1.",
        "difficulty": "Easy",
        "label": [
            "array",
            "search",
            "linear-scan",
            "basic-logic"
        ],
        "sample input": {
            "array": [
                4,
                2,
                9,
                7,
                5
            ],
            "target": 7
        },
        "sample output": 3,
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i], target <= 10^9",
        "_id": 6
    },
    {
        "title": "Count Occurrences of a Character",
        "description": "Given a string and a character, return the number of times the character appears in the string.",
        "difficulty": "Easy",
        "label": [
            "string",
            "frequency-count",
            "iteration",
            "logic"
        ],
        "sample input": {
            "string": "hello world",
            "char": "l"
        },
        "sample output": 3,
        "constraints": "1 <= string length <= 10^5",
        "_id": 7
    },
    {
        "title": "Check if Array is Sorted",
        "description": "Given an array of integers, determine if the array is sorted in non-decreasing order.",
        "difficulty": "Easy",
        "label": [
            "array",
            "sorting",
            "two-pointers",
            "validation"
        ],
        "sample input": [
            1,
            2,
            3,
            4,
            5
        ],
        "sample output": true,
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9",
        "_id": 8
    },
    {
        "title": "Find the First Non-Repeating Character",
        "description": "Given a lowercase string, find the first character that does not repeat. If all characters repeat, return '_' (underscore).",
        "difficulty": "Easy",
        "label": [
            "string",
            "hashmap",
            "frequency-count",
            "iteration"
        ],
        "sample input": "aabbcdde",
        "sample output": "c",
        "constraints": "1 <= string length <= 10^5; only lowercase letters",
        "_id": 9
    },
    {
        "title": "Merge Two Sorted Arrays",
        "description": "Given two sorted arrays, merge them into a single sorted array.",
        "difficulty": "Easy",
        "label": [
            "array",
            "two-pointers",
            "merging",
            "sorting"
        ],
        "sample input": {
            "arr1": [
                1,
                3,
                5
            ],
            "arr2": [
                2,
                4,
                6
            ]
        },
        "sample output": [
            1,
            2,
            3,
            4,
            5,
            6
        ],
        "constraints": "1 <= array lengths <= 10^5; -10^9 <= array elements <= 10^9",
        "_id": 10
    },
    {
        "title": "Minimum Cost to Split Array with Dynamic Programming",
        "description": "You are given an integer array nums and an integer k. You must split the array into several non-empty subarrays. The cost of a subarray is k plus the number of duplicated elements in that subarray. Your task is to minimize the total cost of splitting the entire array. Solve using optimized dynamic programming with hashing.",
        "difficulty": "Hard",
        "label": [
            "dynamic-programming",
            "hashing",
            "optimization",
            "partitioning",
            "array"
        ],
        "sample input": {
            "nums": [
                1,
                2,
                1,
                2,
                1,
                3
            ],
            "k": 2
        },
        "sample output": 8,
        "constraints": "1 <= nums.length <= 10^5; 1 <= nums[i] <= 10^5; 1 <= k <= 10^5; requires O(n log n) or optimized O(n) DP",
        "_id": 11
    },
    {
        "title": "Minimum Number of Increments to Make Array Beautiful",
        "description": "You are given an array of integers. In one operation, you may increment any element by 1. You must make the array 'beautiful', meaning every adjacent pair must follow the rule: arr[i+1] >= 2 * arr[i]. Return the minimum number of operations required. Solve using greedy + mathematical reasoning.",
        "difficulty": "Hard",
        "label": [
            "greedy",
            "math",
            "array",
            "optimization",
            "increment-operations"
        ],
        "sample input": [
            1,
            2,
            3
        ],
        "sample output": 3,
        "constraints": "1 <= array length <= 2*10^5; 1 <= arr[i] <= 10^9; must run in O(n)",
        "_id": 12
    },
    {
        "title": "Shortest Path in a Grid with Obstacles and K Eliminations",
        "description": "Given a matrix grid where 1 represents an obstacle and 0 represents empty space, and an integer k, return the shortest path from (0,0) to (m-1,n-1) where you may eliminate up to k obstacles. Use BFS with state tracking (row, col, remaining-eliminations).",
        "difficulty": "Hard",
        "label": [
            "bfs",
            "graph",
            "grid",
            "state-space-search",
            "shortest-path"
        ],
        "sample input": {
            "grid": [
                [
                    0,
                    1,
                    0
                ],
                [
                    1,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    0
                ]
            ],
            "k": 1
        },
        "sample output": 5,
        "constraints": "1 <= m, n <= 40; 0 <= k <= m*n; requires BFS with visited[row][col][k] state",
        "_id": 13
    },
    {
        "title": "Longest Valid Parentheses with Stack + DP",
        "description": "Given a string containing only '(' and ')', return the length of the longest valid (well-formed) parentheses substring. Must use dynamic programming or a stack-based solution with O(n) complexity. This version includes complex arrangements such as deeply nested and overlapping parentheses.",
        "difficulty": "Hard",
        "label": [
            "dynamic-programming",
            "stack",
            "string",
            "parsing",
            "linear-time"
        ],
        "sample input": "()(())())(()(()))",
        "sample output": 12,
        "constraints": "1 <= string length <= 3*10^5; only '(' and ')'",
        "_id": 14
    },
    {
        "title": "Maximum XOR of Two Numbers in an Array Using Bitwise Trie",
        "description": "Given an array of integers, return the maximum XOR value of any two numbers in the array. Must use a bitwise trie (prefix tree) to achieve O(n) or O(n log C) complexity.",
        "difficulty": "Hard",
        "label": [
            "bitwise",
            "trie",
            "optimization",
            "bit-manipulation",
            "array"
        ],
        "sample input": [
            3,
            10,
            5,
            25,
            2,
            8
        ],
        "sample output": 28,
        "constraints": "1 <= array length <= 2*10^5; 0 <= nums[i] <= 10^9; solution requires advanced bitwise data structures",
        "_id": 15
    },
    {
        "title": "Count Subarrays With Exactly K Distinct Integers Using Sliding Window + Inclusion-Exclusion",
        "description": "Given an integer array nums and an integer k, return the number of subarrays that contain exactly k distinct integers. You must solve it using an optimized sliding-window technique combined with inclusion-exclusion: count(atMost(k)) - count(atMost(k-1)). The challenge is handling large array sizes with tight O(n) complexity.",
        "difficulty": "Hard",
        "label": [
            "sliding-window",
            "hashmap",
            "two-pointers",
            "inclusion-exclusion",
            "array"
        ],
        "sample input": {
            "nums": [
                1,
                2,
                1,
                2,
                3
            ],
            "k": 2
        },
        "sample output": 7,
        "constraints": "1 <= nums.length <= 2*10^5; 1 <= nums[i] <= 10^5; must run in O(n)",
        "_id": 16
    },
    {
        "title": "Minimum Cost to Make String Identical Using Frequency Operations",
        "description": "You are given two strings s and t of the same length. In one operation, you may increase or decrease the character value (a\u2192b\u2192c\u2026) of a position in either string. The cost of changing a character by d positions is d. Return the minimum total cost to transform s into t. Must use prefix-difference balancing + greedy, not DP brute-force. Hard because of long-string constraints and required amortized O(n) reasoning.",
        "difficulty": "Hard",
        "label": [
            "greedy",
            "string",
            "frequency-balancing",
            "optimization",
            "math"
        ],
        "sample input": {
            "s": "abcd",
            "t": "bcaa"
        },
        "sample output": 4,
        "constraints": "1 <= length <= 3*10^5; only lowercase English letters; O(n) or O(n log n) required",
        "_id": 17
    },
    {
        "title": "Maximum Path Sum in a Binary Tree With Negative Weights",
        "description": "Given the root of a binary tree where node values may be negative, return the maximum path sum. A path may start and end at any nodes, but must be continuous and cannot revisit nodes. Must use DFS with global tracking and pruning. Hard because of deep recursion, negative chains, and large trees.",
        "difficulty": "Hard",
        "label": [
            "tree",
            "dfs",
            "divide-and-conquer",
            "recursion",
            "global-optimization"
        ],
        "sample input": {
            "root": [
                1,
                2,
                3
            ]
        },
        "sample output": 6,
        "constraints": "1 <= nodes <= 3*10^5; node values range from -10^9 to 10^9; must run in O(n) DFS",
        "_id": 18
    },
    {
        "title": "Shortest Subarray With Sum At Least K Using Monotonic Deque",
        "description": "Given an integer array nums (positive and negative allowed) and an integer k, return the length of the shortest non-empty subarray with sum >= k. If none exists, return -1. Must use prefix sums + monotonic deque. Hard due to negative values making sliding-window invalid.",
        "difficulty": "Hard",
        "label": [
            "monotonic-queue",
            "prefix-sum",
            "deque",
            "array",
            "optimization"
        ],
        "sample input": {
            "nums": [
                2,
                -1,
                2
            ],
            "k": 3
        },
        "sample output": 3,
        "constraints": "1 <= nums.length <= 2*10^5; -10^9 <= nums[i] <= 10^9; must use O(n) deque approach",
        "_id": 19
    },
    {
        "title": "Earliest Time to Finish All Tasks With Prerequisites Using Topological Sorting + Min-Heap",
        "description": "You are given n tasks labeled 1..n, each with a time to complete. Some tasks depend on others and must be done afterwards. You may execute multiple tasks in parallel whenever available. Return the earliest total completion time. Requires topological sorting combined with a min-heap priority structure to parallelize tasks optimally. Hard because of graph structure, large constraints, and priority scheduling.",
        "difficulty": "Hard",
        "label": [
            "graph",
            "topological-sort",
            "priority-queue",
            "dag",
            "scheduling"
        ],
        "sample input": {
            "n": 4,
            "times": [
                3,
                1,
                2,
                4
            ],
            "dependencies": [
                [
                    1,
                    2
                ],
                [
                    1,
                    3
                ],
                [
                    3,
                    4
                ]
            ]
        },
        "sample output": 7,
        "constraints": "1 <= n <= 2*10^5; DAG guaranteed; total edges <= 3*10^5; must run in O(n log n)",
        "_id": 20
    },
    {
        "title": "Longest Subarray with Sum K",
        "description": "Given an integer array and an integer K, find the length of the longest contiguous subarray whose sum equals K. If no such subarray exists, return 0.",
        "difficulty": "Medium",
        "label": [
            "array",
            "hashing",
            "prefix-sum",
            "sliding-window"
        ],
        "sample input": {
            "array": [
                1,
                -1,
                5,
                -2,
                3
            ],
            "K": 3
        },
        "sample output": 4,
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9; -10^18 <= K <= 10^18",
        "_id": 21
    },
    {
        "title": "Kth Smallest Element in Unsorted Array",
        "description": "Given an unsorted array of integers and an integer k, return the k-th smallest element in the array (1-indexed). Aim for average O(n) time using selection (quickselect) or O(n log n) by sorting.",
        "difficulty": "Medium",
        "label": [
            "array",
            "selection",
            "quickselect",
            "divide-and-conquer",
            "sorting"
        ],
        "sample input": {
            "array": [
                7,
                10,
                4,
                3,
                20,
                15
            ],
            "k": 3
        },
        "sample output": 7,
        "constraints": "1 <= array length <= 2*10^5; -10^9 <= array[i] <= 10^9; 1 <= k <= array length",
        "_id": 22
    },
    {
        "title": "Top K Frequent Elements",
        "description": "Given a non-empty array of integers, return the k most frequent elements. The order of the returned elements does not matter. Use a heap or bucket sort for improved complexity.",
        "difficulty": "Medium",
        "label": [
            "hashing",
            "heap",
            "bucket-sort",
            "frequency-count",
            "array"
        ],
        "sample input": {
            "array": [
                1,
                1,
                1,
                2,
                2,
                3
            ],
            "k": 2
        },
        "sample output": [
            1,
            2
        ],
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9; 1 <= k <= number of unique elements",
        "_id": 23
    },
    {
        "title": "Product of Array Except Self",
        "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. Solve it without using division and in O(n) time.",
        "difficulty": "Medium",
        "label": [
            "array",
            "prefix-product",
            "suffix-product",
            "space-optimization"
        ],
        "sample input": [
            1,
            2,
            3,
            4
        ],
        "sample output": [
            24,
            12,
            8,
            6
        ],
        "constraints": "2 <= array length <= 10^5; -10^5 <= array[i] <= 10^5; product fits in 64-bit signed integer",
        "_id": 24
    },
    {
        "title": "Minimum Window Substring (Contain All Characters)",
        "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return an empty string. Aim for O(n) using sliding-window + hashmap.",
        "difficulty": "Medium",
        "label": [
            "string",
            "sliding-window",
            "hashmap",
            "two-pointers",
            "substring"
        ],
        "sample input": {
            "s": "ADOBECODEBANC",
            "t": "ABC"
        },
        "sample output": "BANC",
        "constraints": "1 <= |s|, |t| <= 10^5; s and t consist of ASCII characters",
        "_id": 25
    },
    {
        "title": "Rotate Array by K Positions",
        "description": "Given an array of integers, rotate the array to the right by k steps. Perform the rotation in-place with O(1) extra space.",
        "difficulty": "Medium",
        "label": [
            "array",
            "two-pointers",
            "in-place",
            "rotation",
            "manipulation"
        ],
        "sample input": {
            "array": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "k": 3
        },
        "sample output": [
            5,
            6,
            7,
            1,
            2,
            3,
            4
        ],
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9; 0 <= k <= 10^9",
        "_id": 26
    },
    {
        "title": "Binary Search on Rotated Sorted Array",
        "description": "Given a rotated sorted array and a target integer, return the index of the target if found, otherwise return -1. Use modified binary search with O(log n) complexity.",
        "difficulty": "Medium",
        "label": [
            "array",
            "binary-search",
            "rotation",
            "divide-and-conquer",
            "search"
        ],
        "sample input": {
            "array": [
                4,
                5,
                6,
                7,
                0,
                1,
                2
            ],
            "target": 0
        },
        "sample output": 4,
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i], target <= 10^9",
        "_id": 27
    },
    {
        "title": "Longest Increasing Subsequence (LIS)",
        "description": "Given an array of integers, return the length of the longest strictly increasing subsequence. Solve using dynamic programming or optimized binary-search approach.",
        "difficulty": "Medium",
        "label": [
            "array",
            "dynamic-programming",
            "binary-search",
            "subsequence",
            "optimization"
        ],
        "sample input": [
            10,
            9,
            2,
            5,
            3,
            7,
            101,
            18
        ],
        "sample output": 4,
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9",
        "_id": 28
    },
    {
        "title": "Group Anagrams",
        "description": "Given an array of strings, group the strings that are anagrams of each other. Return a list of grouped anagrams in any order.",
        "difficulty": "Medium",
        "label": [
            "string",
            "hashmap",
            "sorting",
            "frequency-hash",
            "grouping"
        ],
        "sample input": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
        ],
        "sample output": [
            [
                "eat",
                "tea",
                "ate"
            ],
            [
                "tan",
                "nat"
            ],
            [
                "bat"
            ]
        ],
        "constraints": "1 <= number of strings <= 10^5; string length <= 50; strings consist of lowercase letters",
        "_id": 29
    },
    {
        "title": "Find Peak Element",
        "description": "A peak element is an element that is strictly greater than its neighbors. Given an array, return the index of any peak element. Solve in O(log n) using binary search.",
        "difficulty": "Medium",
        "label": [
            "array",
            "binary-search",
            "optimization",
            "peak-finding",
            "divide-and-conquer"
        ],
        "sample input": [
            1,
            2,
            1,
            3,
            5,
            6,
            4
        ],
        "sample output": 5,
        "constraints": "1 <= array length <= 10^5; -10^9 <= array[i] <= 10^9",
        "_id": 30
    },
    {
        "title": "Select All Rows From Employee Table",
        "description": "Write an SQL query to retrieve all rows and all columns from a table named Employees.",
        "difficulty": "Easy",
        "label": [
            "select",
            "basic-sql",
            "retrieval"
        ],
        "sample input": {
            "table": "Employees"
        },
        "sample output": "SELECT * FROM Employees;",
        "constraints": "Employees table exists with any number of columns; no filtering required",
        "_id": 31
    },
    {
        "title": "Select Specific Columns From a Table",
        "description": "Write an SQL query to return only the name and salary columns from the Employees table.",
        "difficulty": "Easy",
        "label": [
            "select",
            "columns",
            "basic-sql"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "name",
                "salary"
            ]
        },
        "sample output": "SELECT name, salary FROM Employees;",
        "constraints": "Columns name and salary must exist in Employees",
        "_id": 32
    },
    {
        "title": "Filter Employees With Salary Greater Than 50000",
        "description": "Write an SQL query to retrieve all employees whose salary is greater than 50000.",
        "difficulty": "Easy",
        "label": [
            "where-clause",
            "comparison",
            "filtering"
        ],
        "sample input": {
            "table": "Employees",
            "condition": "salary > 50000"
        },
        "sample output": "SELECT * FROM Employees WHERE salary > 50000;",
        "constraints": "Salary column must exist and be numeric",
        "_id": 33
    },
    {
        "title": "Sort Employees by Age in Ascending Order",
        "description": "Write an SQL query to return all employees sorted by their age in ascending order.",
        "difficulty": "Easy",
        "label": [
            "order-by",
            "sorting",
            "select"
        ],
        "sample input": {
            "table": "Employees",
            "order": "age ASC"
        },
        "sample output": "SELECT * FROM Employees ORDER BY age ASC;",
        "constraints": "Age column must exist; sort must be ascending",
        "_id": 34
    },
    {
        "title": "Count Total Number of Employees",
        "description": "Write an SQL query to count how many employees are present in the Employees table.",
        "difficulty": "Easy",
        "label": [
            "aggregate",
            "count",
            "basic-sql"
        ],
        "sample input": {
            "table": "Employees"
        },
        "sample output": "SELECT COUNT(*) FROM Employees;",
        "constraints": "Employees table exists; COUNT(*) must be used",
        "_id": 35
    },
    {
        "title": "Find Unique Departments",
        "description": "Write an SQL query to return a list of unique department names from the Departments table.",
        "difficulty": "Easy",
        "label": [
            "distinct",
            "select",
            "basic-sql"
        ],
        "sample input": {
            "table": "Departments",
            "column": "department_name"
        },
        "sample output": "SELECT DISTINCT department_name FROM Departments;",
        "constraints": "department_name column must exist; DISTINCT must be used",
        "_id": 36
    },
    {
        "title": "Find Employees With NULL Phone Number",
        "description": "Write an SQL query to retrieve all employees whose phone_number value is NULL.",
        "difficulty": "Easy",
        "label": [
            "null-check",
            "filtering",
            "where-clause"
        ],
        "sample input": {
            "table": "Employees",
            "column": "phone_number"
        },
        "sample output": "SELECT * FROM Employees WHERE phone_number IS NULL;",
        "constraints": "phone_number column may contain NULL values",
        "_id": 37
    },
    {
        "title": "Retrieve Employees With Name Starting With 'A'",
        "description": "Write an SQL query to fetch all employees whose name starts with the letter 'A'.",
        "difficulty": "Easy",
        "label": [
            "like-operator",
            "pattern-matching",
            "filtering"
        ],
        "sample input": {
            "table": "Employees",
            "column": "name",
            "pattern": "A%"
        },
        "sample output": "SELECT * FROM Employees WHERE name LIKE 'A%';",
        "constraints": "name column must exist; LIKE operator must be used",
        "_id": 38
    },
    {
        "title": "Get Top 5 Highest Salaries",
        "description": "Write an SQL query to return the top 5 employees with the highest salary.",
        "difficulty": "Easy",
        "label": [
            "limit",
            "order-by",
            "sorting"
        ],
        "sample input": {
            "table": "Employees",
            "column": "salary",
            "limit": 5
        },
        "sample output": "SELECT * FROM Employees ORDER BY salary DESC LIMIT 5;",
        "constraints": "salary column must exist; LIMIT or FETCH FIRST syntax depending on SQL dialect",
        "_id": 39
    },
    {
        "title": "Calculate Average Salary of Employees",
        "description": "Write an SQL query to compute the average salary of all employees.",
        "difficulty": "Easy",
        "label": [
            "aggregate",
            "avg",
            "basic-sql"
        ],
        "sample input": {
            "table": "Employees"
        },
        "sample output": "SELECT AVG(salary) FROM Employees;",
        "constraints": "salary column must exist and be numeric",
        "_id": 40
    },
    {
        "title": "Find Employees With Salary Above Their Department Average",
        "description": "Write an SQL query to find all employees whose salary is greater than the average salary of their respective department. Use GROUP BY and a subquery.",
        "difficulty": "Medium",
        "label": [
            "subquery",
            "group-by",
            "aggregate",
            "comparison"
        ],
        "sample input": {
            "table1": "Employees",
            "columns1": [
                "id",
                "name",
                "salary",
                "department_id"
            ],
            "table2": "Departments",
            "columns2": [
                "department_id",
                "department_name"
            ]
        },
        "sample output": "SELECT e.name, e.salary FROM Employees e WHERE e.salary > (SELECT AVG(salary) FROM Employees WHERE department_id = e.department_id);",
        "constraints": "department_id must exist; must use subquery with AVG()",
        "_id": 41
    },
    {
        "title": "Retrieve Departments With More Than 5 Employees",
        "description": "Write an SQL query to list all departments that have more than 5 employees. Use GROUP BY and HAVING.",
        "difficulty": "Medium",
        "label": [
            "group-by",
            "having",
            "aggregate"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "department_id"
            ]
        },
        "sample output": "SELECT department_id, COUNT(*) AS total_employees FROM Employees GROUP BY department_id HAVING COUNT(*) > 5;",
        "constraints": "department_id must exist; HAVING clause must be used",
        "_id": 42
    },
    {
        "title": "Find Employees Who Earn the Maximum Salary in Their Department",
        "description": "Write an SQL query to return employee names who earn the maximum salary within their department. Use a subquery or JOIN.",
        "difficulty": "Medium",
        "label": [
            "subquery",
            "join",
            "group-by",
            "aggregate"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "name",
                "department_id",
                "salary"
            ]
        },
        "sample output": "SELECT e.name, e.department_id FROM Employees e WHERE salary = (SELECT MAX(salary) FROM Employees WHERE department_id = e.department_id);",
        "constraints": "department_id and salary must exist; MAX() must be used",
        "_id": 43
    },
    {
        "title": "List Employees and Their Managers Using Self Join",
        "description": "Write an SQL query to list each employee along with their manager\u2019s name using a self join on the Employees table.",
        "difficulty": "Medium",
        "label": [
            "self-join",
            "join",
            "relational-data"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "id",
                "name",
                "manager_id"
            ]
        },
        "sample output": "SELECT e.name AS employee, m.name AS manager FROM Employees e LEFT JOIN Employees m ON e.manager_id = m.id;",
        "constraints": "manager_id may be NULL; must use self join",
        "_id": 44
    },
    {
        "title": "Find Products With Price Higher Than the Average Price of All Products",
        "description": "Write an SQL query to return all product names whose price is greater than the overall average product price.",
        "difficulty": "Medium",
        "label": [
            "subquery",
            "aggregate",
            "filtering"
        ],
        "sample input": {
            "table": "Products",
            "columns": [
                "product_name",
                "price"
            ]
        },
        "sample output": "SELECT product_name FROM Products WHERE price > (SELECT AVG(price) FROM Products);",
        "constraints": "price must exist and be numeric; use AVG() in subquery",
        "_id": 45
    },
    {
        "title": "Find Customers Who Placed More Than 2 Orders",
        "description": "Write an SQL query to list all customers who have placed more than 2 orders. Use GROUP BY and HAVING.",
        "difficulty": "Medium",
        "label": [
            "group-by",
            "having",
            "aggregation",
            "filtering"
        ],
        "sample input": {
            "table": "Orders",
            "columns": [
                "customer_id",
                "order_id"
            ]
        },
        "sample output": "SELECT customer_id, COUNT(*) AS total_orders FROM Orders GROUP BY customer_id HAVING COUNT(*) > 2;",
        "constraints": "customer_id must exist; must use HAVING with COUNT()",
        "_id": 46
    },
    {
        "title": "Retrieve Products Never Purchased",
        "description": "Write an SQL query to find all products that have never been ordered. Use LEFT JOIN and NULL filtering.",
        "difficulty": "Medium",
        "label": [
            "join",
            "left-join",
            "null-check",
            "filtering"
        ],
        "sample input": {
            "table1": "Products",
            "columns1": [
                "product_id",
                "product_name"
            ],
            "table2": "OrderItems",
            "columns2": [
                "product_id"
            ]
        },
        "sample output": "SELECT p.product_name FROM Products p LEFT JOIN OrderItems o ON p.product_id = o.product_id WHERE o.product_id IS NULL;",
        "constraints": "product_id must exist in both tables; use LEFT JOIN",
        "_id": 47
    },
    {
        "title": "Find Employees With the Second Highest Salary",
        "description": "Write an SQL query to find all employees who have the second highest salary. Use a subquery or DISTINCT logic.",
        "difficulty": "Medium",
        "label": [
            "subquery",
            "ordering",
            "distinct",
            "filtering"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "name",
                "salary"
            ]
        },
        "sample output": "SELECT name FROM Employees WHERE salary = (SELECT DISTINCT salary FROM Employees ORDER BY salary DESC LIMIT 1 OFFSET 1);",
        "constraints": "salary must be numeric; solution must identify the 2nd highest",
        "_id": 48
    },
    {
        "title": "List Customers and Their Total Spending",
        "description": "Write an SQL query to list each customer along with the total amount they have spent. Use SUM() with GROUP BY.",
        "difficulty": "Medium",
        "label": [
            "aggregate",
            "group-by",
            "sum",
            "join"
        ],
        "sample input": {
            "table1": "Customers",
            "columns1": [
                "customer_id",
                "customer_name"
            ],
            "table2": "Orders",
            "columns2": [
                "order_id",
                "customer_id",
                "amount"
            ]
        },
        "sample output": "SELECT c.customer_name, SUM(o.amount) AS total_spent FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id GROUP BY c.customer_name;",
        "constraints": "amount must exist; must use SUM() with GROUP BY",
        "_id": 49
    },
    {
        "title": "Find Average Salary Per Department",
        "description": "Write an SQL query to return each department along with the average salary of employees in that department.",
        "difficulty": "Medium",
        "label": [
            "group-by",
            "aggregate",
            "avg",
            "join"
        ],
        "sample input": {
            "table1": "Employees",
            "columns1": [
                "salary",
                "department_id"
            ],
            "table2": "Departments",
            "columns2": [
                "department_id",
                "department_name"
            ]
        },
        "sample output": "SELECT d.department_name, AVG(e.salary) AS average_salary FROM Employees e JOIN Departments d ON e.department_id = d.department_id GROUP BY d.department_name;",
        "constraints": "salary must be numeric; must use GROUP BY with AVG()",
        "_id": 50
    },
    {
        "title": "Find Employees With Salaries Above Their Department Average",
        "description": "Write an SQL query to list all employees whose salary is greater than the average salary of their respective department. Use a correlated subquery.",
        "difficulty": "Hard",
        "label": [
            "correlated-subquery",
            "aggregation",
            "comparison",
            "filtering"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "employee_id",
                "employee_name",
                "department_id",
                "salary"
            ]
        },
        "sample output": "SELECT employee_name FROM Employees e WHERE salary > (SELECT AVG(salary) FROM Employees WHERE department_id = e.department_id);",
        "constraints": "Must use correlated subquery; salary must be numeric",
        "_id": 51
    },
    {
        "title": "Retrieve Top 3 Salaries Per Department",
        "description": "Write an SQL query to fetch the top 3 highest salaries in each department using window functions such as DENSE_RANK.",
        "difficulty": "Hard",
        "label": [
            "window-functions",
            "ranking",
            "partition-by",
            "ordering",
            "analytics"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "employee_id",
                "employee_name",
                "department_id",
                "salary"
            ]
        },
        "sample output": "SELECT employee_name, department_id, salary FROM (SELECT *, DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rnk FROM Employees) t WHERE rnk <= 3;",
        "constraints": "Must use window function; must handle tied salaries",
        "_id": 52
    },
    {
        "title": "Find Customers Who Purchased Every Product",
        "description": "Write an SQL query to find all customers who have bought every product available. Use NOT EXISTS (set-division logic).",
        "difficulty": "Hard",
        "label": [
            "set-division",
            "subquery",
            "not-exists",
            "join",
            "filtering"
        ],
        "sample input": {
            "table1": "Customers",
            "columns1": [
                "customer_id",
                "customer_name"
            ],
            "table2": "Orders",
            "columns2": [
                "customer_id",
                "product_id"
            ],
            "table3": "Products",
            "columns3": [
                "product_id"
            ]
        },
        "sample output": "SELECT c.customer_name FROM Customers c WHERE NOT EXISTS (SELECT p.product_id FROM Products p WHERE NOT EXISTS (SELECT 1 FROM Orders o WHERE o.customer_id = c.customer_id AND o.product_id = p.product_id));",
        "constraints": "Must use double NOT EXISTS; cannot use COUNT comparison",
        "_id": 53
    },
    {
        "title": "Identify Users With 3+ Consecutive Login Days",
        "description": "Write an SQL query to find users who logged in for at least 3 consecutive days. Use ROW_NUMBER or date arithmetic logic to detect streaks.",
        "difficulty": "Hard",
        "label": [
            "window-functions",
            "date-functions",
            "grouping",
            "analytics"
        ],
        "sample input": {
            "table": "Logins",
            "columns": [
                "user_id",
                "login_date"
            ]
        },
        "sample output": "SELECT user_id FROM (SELECT user_id, login_date, DATE(login_date) - INTERVAL ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY login_date) DAY AS grp FROM Logins) t GROUP BY user_id, grp HAVING COUNT(*) >= 3;",
        "constraints": "Must use ROW_NUMBER to find sequences; date format must support subtraction",
        "_id": 54
    },
    {
        "title": "Calculate Month-over-Month Revenue Growth",
        "description": "Write an SQL query to calculate the Month-over-Month percentage growth in revenue. Use LAG() and aggregated monthly totals.",
        "difficulty": "Hard",
        "label": [
            "lag",
            "window-functions",
            "aggregation",
            "date-grouping",
            "analytics"
        ],
        "sample input": {
            "table": "Sales",
            "columns": [
                "sale_id",
                "amount",
                "sale_date"
            ]
        },
        "sample output": "SELECT month, revenue, (revenue - LAG(revenue) OVER (ORDER BY month)) * 100.0 / LAG(revenue) OVER (ORDER BY month) AS growth_percentage FROM (SELECT DATE_FORMAT(sale_date, '%Y-%m') AS month, SUM(amount) AS revenue FROM Sales GROUP BY month) t;",
        "constraints": "Must use LAG; must calculate growth percentage",
        "_id": 55
    },
    {
        "title": "Find Products Whose Price Increased for 3 Consecutive Months",
        "description": "Given a product pricing history table, write a query to find all products whose price strictly increased for 3 consecutive months or more. Use window functions such as LAG combined with grouping on consecutive sequences.",
        "difficulty": "Hard",
        "label": [
            "window-functions",
            "lag",
            "consecutive-patterns",
            "analytics",
            "grouping"
        ],
        "sample input": {
            "table": "ProductPriceHistory",
            "columns": [
                "product_id",
                "price",
                "month"
            ]
        },
        "sample output": "SELECT DISTINCT product_id FROM (SELECT product_id, month, price, CASE WHEN price > LAG(price) OVER (PARTITION BY product_id ORDER BY month) THEN 1 ELSE 0 END AS inc FROM ProductPriceHistory) t;",
        "constraints": "month is unique per product; requires LAG and detection of consecutive increases",
        "_id": 56
    },
    {
        "title": "Identify Employees Whose Salary Is Above the 90th Percentile in Their Department",
        "description": "Write an SQL query to list employees whose salary is above the 90th percentile of their department using window functions or percentile_cont().",
        "difficulty": "Hard",
        "label": [
            "percentile",
            "window-functions",
            "analytics",
            "subquery"
        ],
        "sample input": {
            "table": "Employees",
            "columns": [
                "employee_id",
                "department_id",
                "salary"
            ]
        },
        "sample output": "SELECT employee_id FROM (SELECT employee_id, salary, PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY salary) OVER (PARTITION BY department_id) AS p90 FROM Employees) t WHERE salary > p90;",
        "constraints": "requires percentile calculation; supported in most SQL analytical engines",
        "_id": 57
    },
    {
        "title": "Find All Customers Whose Total Spending Is in the Top 5% Across All Customers",
        "description": "Write a query to calculate each customer's total spending and then return only those in the top 5% using window functions and ranking.",
        "difficulty": "Hard",
        "label": [
            "window-functions",
            "ranking",
            "aggregate",
            "percentile",
            "analytics"
        ],
        "sample input": {
            "table": "Orders",
            "columns": [
                "customer_id",
                "order_amount"
            ]
        },
        "sample output": "SELECT customer_id FROM (SELECT customer_id, SUM(order_amount) AS total_spent, NTILE(20) OVER (ORDER BY SUM(order_amount) DESC) AS nt FROM Orders GROUP BY customer_id) t WHERE nt = 1;",
        "constraints": "requires NTILE or ranking; orders table may have millions of rows",
        "_id": 58
    },
    {
        "title": "Detect Employees Who Worked on Every Project in Their Department",
        "description": "Write a query to find employees who have worked on every project assigned to their department. This is a classic relational division problem requiring double NOT EXISTS.",
        "difficulty": "Hard",
        "label": [
            "relational-division",
            "set-logic",
            "not-exists",
            "advanced-join"
        ],
        "sample input": {
            "table1": "EmployeeProjects",
            "columns1": [
                "employee_id",
                "project_id"
            ],
            "table2": "Projects",
            "columns2": [
                "project_id",
                "department_id"
            ],
            "table3": "Employees",
            "columns3": [
                "employee_id",
                "department_id"
            ]
        },
        "sample output": "SELECT e.employee_id FROM Employees e WHERE NOT EXISTS (SELECT project_id FROM Projects p WHERE p.department_id = e.department_id AND NOT EXISTS (SELECT 1 FROM EmployeeProjects ep WHERE ep.employee_id = e.employee_id AND ep.project_id = p.project_id));",
        "constraints": "requires correlated double NOT EXISTS; extremely advanced SQL logic",
        "_id": 59
    },
    {
        "title": "Find the Longest Consecutive Login Streak per User",
        "description": "Given a table of user login dates, write a query to find the longest consecutive login streak for each user. Use window functions, date arithmetic, and streak grouping logic.",
        "difficulty": "Hard",
        "label": [
            "window-functions",
            "date-logic",
            "consecutive-patterns",
            "analytics"
        ],
        "sample input": {
            "table": "UserLogins",
            "columns": [
                "user_id",
                "login_date"
            ]
        },
        "sample output": "SELECT user_id, MAX(streak_length) FROM (SELECT user_id, login_date, ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY login_date) AS rn FROM UserLogins) t GROUP BY user_id;",
        "constraints": "login_date must be unique per user; streak detection requires grouping by (login_date - rn)",
        "_id": 60
    }
]